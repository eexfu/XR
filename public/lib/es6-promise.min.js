/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE
 * @version   3.2.1
 */

(function() {function t(t) {return typeof t === 'function' || typeof t === 'object' && t !== null;} function e(t) {return typeof t === 'function';} function n(t) {G = t;} function r(t) {Q = t;} function o() {return function() {process.nextTick(a);};} function i() {return function() {B(a);};} function s() {let t = 0; const e = new X(a); const n = document.createTextNode(''); return e.observe(n, {characterData: !0}), function() {n.data = t = ++t % 2;};} function u() {const t = new MessageChannel(); return t.port1.onmessage = a, function() {t.port2.postMessage(0);};} function c() {return function() {setTimeout(a, 1);};} function a() {for (let t = 0; J > t; t += 2) {const e = tt[t]; const n = tt[t + 1]; e(n), tt[t] = void 0, tt[t + 1] = void 0;}J = 0;} function f() {try {const t = require; const e = t('vertx'); return B = e.runOnLoop || e.runOnContext, i();} catch (n) {return c();}} function l(t, e) {const n = this; const r = new this.constructor(p); void 0 === r[rt] && k(r); const o = n._state; if (o) {const i = arguments[o - 1]; Q(() => {x(o, r, i, n._result);});} else E(n, r, t, e); return r;} function h(t) {const e = this; if (t && typeof t === 'object' && t.constructor === e) return t; const n = new e(p); return g(n, t), n;} function p() {} function _() {return new TypeError('You cannot resolve a promise with itself');} function d() {return new TypeError('A promises callback cannot return that same promise.');} function v(t) {try {return t.then;} catch (e) {return ut.error = e, ut;}} function y(t, e, n, r) {try {t.call(e, n, r);} catch (o) {return o;}} function m(t, e, n) {Q((t) => {let r = !1; const o = y(n, e, (n) => {r || (r = !0, e !== n ? g(t, n) : S(t, n));}, (e) => {r || (r = !0, j(t, e));}, `Settle: ${t._label || ' unknown promise'}`); !r && o && (r = !0, j(t, o));}, t);} function b(t, e) {e._state === it ? S(t, e._result) : e._state === st ? j(t, e._result) : E(e, void 0, (e) => {g(t, e);}, (e) => {j(t, e);});} function w(t, n, r) {n.constructor === t.constructor && r === et && constructor.resolve === nt ? b(t, n) : r === ut ? j(t, ut.error) : void 0 === r ? S(t, n) : e(r) ? m(t, n, r) : S(t, n);} function g(e, n) {e === n ? j(e, _()) : t(n) ? w(e, n, v(n)) : S(e, n);} function A(t) {t._onerror && t._onerror(t._result), T(t);} function S(t, e) {t._state === ot && (t._result = e, t._state = it, t._subscribers.length !== 0 && Q(T, t));} function j(t, e) {t._state === ot && (t._state = st, t._result = e, Q(A, t));} function E(t, e, n, r) {const o = t._subscribers; const i = o.length; t._onerror = null, o[i] = e, o[i + it] = n, o[i + st] = r, i === 0 && t._state && Q(T, t);} function T(t) {const e = t._subscribers; const n = t._state; if (e.length !== 0) {for (var r, o, i = t._result, s = 0; s < e.length; s += 3)r = e[s], o = e[s + n], r ? x(n, r, o, i) : o(i); t._subscribers.length = 0;}} function M() {this.error = null;} function P(t, e) {try {return t(e);} catch (n) {return ct.error = n, ct;}} function x(t, n, r, o) {let i; let s; let u; let c; const a = e(r); if (a) {if (i = P(r, o), i === ct ? (c = !0, s = i.error, i = null) : u = !0, n === i) return void j(n, d());} else i = o, u = !0; n._state !== ot || (a && u ? g(n, i) : c ? j(n, s) : t === it ? S(n, i) : t === st && j(n, i));} function C(t, e) {try {e((e) => {g(t, e);}, (e) => {j(t, e);});} catch (n) {j(t, n);}} function O() {return at++;} function k(t) {t[rt] = at++, t._state = void 0, t._result = void 0, t._subscribers = [];} function Y(t) {return new _t(this, t).promise;} function q(t) {const e = this; return new e(I(t) ? (n, r) => {for (let o = t.length, i = 0; o > i; i++)e.resolve(t[i]).then(n, r);} : (t, e) => {e(new TypeError('You must pass an array to race.'));});} function F(t) {const e = this; const n = new e(p); return j(n, t), n;} function D() {throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');} function K() {throw new TypeError('Failed to construct \'Promise\': Please use the \'new\' operator, this object constructor cannot be called as a function.');} function L(t) {this[rt] = O(), this._result = this._state = void 0, this._subscribers = [], p !== t && (typeof t !== 'function' && D(), this instanceof L ? C(this, t) : K());} function N(t, e) {this._instanceConstructor = t, this.promise = new t(p), this.promise[rt] || k(this.promise), I(e) ? (this._input = e, this.length = e.length, this._remaining = e.length, this._result = new Array(this.length), this.length === 0 ? S(this.promise, this._result) : (this.length = this.length || 0, this._enumerate(), this._remaining === 0 && S(this.promise, this._result))) : j(this.promise, U());} function U() {return new Error('Array Methods must be provided an Array');} function W() {let t; if (typeof global !== 'undefined')t = global; else if (typeof self !== 'undefined')t = self; else try {t = Function('return this')();} catch (e) {throw new Error('polyfill failed because global object is unavailable in this environment');} const n = t.Promise; (!n || Object.prototype.toString.call(n.resolve()) !== '[object Promise]' || n.cast) && (t.Promise = pt);} let z; z = Array.isArray ? Array.isArray : function(t) {return Object.prototype.toString.call(t) === '[object Array]';}; let B; let G; let H; var I = z; var J = 0; var Q = function(t, e) {tt[J] = t, tt[J + 1] = e, J += 2, J === 2 && (G ? G(a) : H());}; const R = typeof window !== 'undefined' ? window : void 0; const V = R || {}; var X = V.MutationObserver || V.WebKitMutationObserver; const Z = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]'; const $ = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined'; var tt = new Array(1e3); H = Z ? o() : X ? s() : $ ? u() : void 0 === R && typeof require === 'function' ? f() : c(); var et = l; var nt = h; var rt = Math.random().toString(36).substring(16); var ot = void 0; var it = 1; var st = 2; var ut = new M(); var ct = new M(); var at = 0; const ft = Y; const lt = q; const ht = F; var pt = L; L.all = ft, L.race = lt, L.resolve = nt, L.reject = ht, L._setScheduler = n, L._setAsap = r, L._asap = Q, L.prototype = {constructor: L, then: et, catch(t) {return this.then(null, t);}}; var _t = N; N.prototype._enumerate = function() {for (let t = this.length, e = this._input, n = 0; this._state === ot && t > n; n++) this._eachEntry(e[n], n);}, N.prototype._eachEntry = function(t, e) {const n = this._instanceConstructor; const r = n.resolve; if (r === nt) {const o = v(t); if (o === et && t._state !== ot) this._settledAt(t._state, e, t._result); else if (typeof o !== 'function') this._remaining--, this._result[e] = t; else if (n === pt) {const i = new n(p); w(i, t, o), this._willSettleAt(i, e);} else this._willSettleAt(new n((e) => {e(t);}), e);} else this._willSettleAt(r(t), e);}, N.prototype._settledAt = function(t, e, n) {const r = this.promise; r._state === ot && (this._remaining--, t === st ? j(r, n) : this._result[e] = n), this._remaining === 0 && S(r, this._result);}, N.prototype._willSettleAt = function(t, e) {const n = this; E(t, void 0, (t) => {n._settledAt(it, e, t);}, (t) => {n._settledAt(st, e, t);});}; const dt = W; const vt = {Promise: pt, polyfill: dt}; typeof define === 'function' && define.amd ? define(() => vt) : typeof module !== 'undefined' && module.exports ? module.exports = vt : typeof this !== 'undefined' && (this.ES6Promise = vt), dt();}).call(this);
